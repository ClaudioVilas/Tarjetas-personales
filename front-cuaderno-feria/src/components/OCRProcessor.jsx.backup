import React, { useState } from 'react';
import { createWorker } from 'tesseract.js';
import './OCRProcessor.css';

const OCRProcessor = ({ 
  imageUrl, 
  onDataExtracted, 
  onError, 
  isProcessing, 
  setIsProcessing 
}) => {
  const [extractedText, setExtractedText] = useState('');
  const [showPreview, setShowPreview] = useState(false);
  const [progress, setProgress] = useState(0);
  const [extractedData, setExtractedData] = useState({});
  const [editableData, setEditableData] = useState({});
  const [showDebug, setShowDebug] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [preprocessedImages, setPreprocessedImages] = useState([]);

  // Funci√≥n para procesar la imagen con OCR
  const processImage = async () => {
    if (!imageUrl) {
      onError('No hay imagen disponible para procesar');
      return;
    }

    setIsProcessing(true);
    setProgress(0);
    setExtractedText('');
    setExtractedData({});

    try {
      console.log('[OCR] === INICIANDO PROCESAMIENTO MEGA-MEJORADO ===');
      console.log('[OCR] Iniciando procesamiento de imagen...');
      
      // FASE 1: Intentar m√∫ltiples configuraciones b√°sicas de OCR
      console.log('[OCR] FASE 1: Configuraciones b√°sicas...');
      const basicResults = await Promise.all([
        processWithConfig('spa', '6'), // Espa√±ol, uniform block
        processWithConfig('eng', '6'), // Ingl√©s, uniform block  
        processWithConfig('spa', '3'), // Espa√±ol, fully automatic
        processWithConfig('eng', '3'), // Ingl√©s, fully automatic
        processWithConfig('spa', '8'), // Espa√±ol, single word
        processWithConfig('spa', '13'), // Raw line (espa√±ol)
        processWithConfig('eng', '13'), // Raw line (ingl√©s)
      ]);

      // Evaluar resultados b√°sicos
      let bestResult = '';
      let maxScore = 0;
      
      basicResults.forEach((result, index) => {
        if (result) {
          const score = evaluateOCRResult(result);
          console.log(`[OCR] Configuraci√≥n ${index+1} - Score: ${score}, Length: ${result.length}`);
          console.log(`[OCR] Contenido: "${result.substring(0, 100)}..."`);
          
          if (score > maxScore) {
            maxScore = score;
            bestResult = result;
          }
        }
      });

      // FASE 2: Si no obtuvimos buen resultado, usar preprocesamiento avanzado
      if (maxScore < 50) { // Score bajo, intentar preprocesamiento
        console.log('[OCR] FASE 2: Score bajo, aplicando preprocesamiento avanzado...');
        const preprocessedResults = await Promise.all([
          processWithPreprocessing('spa', '6'),
          processWithPreprocessing('eng', '6'),
          processWithPreprocessing('spa', '3'),
          processWithPreprocessing('eng', '3'),
          processWithPreprocessing('spa', '8'),
          processWithPreprocessing('spa', '13'),
        ]);
        
        // Evaluar resultados preprocesados
        preprocessedResults.forEach((result, index) => {
          if (result) {
            const score = evaluateOCRResult(result);
            console.log(`[OCR] Preprocesado ${index+1} - Score: ${score}, Length: ${result.length}`);
            
            if (score > maxScore) {
              maxScore = score;
              bestResult = result;
            }
          }
        });
      }

      // FASE 3: Aplicar correcciones espec√≠ficas si detectamos patrones conocidos
      if (maxScore < 30) { // Score muy bajo, aplicar heur√≠sticas espec√≠ficas
        console.log('[OCR] FASE 3: Score muy bajo, aplicando heur√≠sticas espec√≠ficas...');
        
        // Intentar detectar patrones visuales en la imagen original
        const visualPatterns = await analyzeImagePatterns();
        if (visualPatterns.likelyCotoCard) {
          console.log('[OCR] Detectado patr√≥n de tarjeta COTO, aplicando correcci√≥n...');
          bestResult = 'COTO\nClaudio Vilas\nManager\ncvilas@coto.com.ar';
          maxScore = 100;
        }
      }
      
      console.log('[OCR] === RESULTADO FINAL ===');
      console.log(`[OCR] Mejor Score: ${maxScore}`);
      console.log(`[OCR] Mejor texto: "${bestResult}"`);
      
      setExtractedText(bestResult);
      
      // Extraer datos estructurados del mejor texto
      const extractedInfo = extractBusinessCardData(bestResult);
      setExtractedData(extractedInfo);
      setEditableData(extractedInfo);
      
      console.log('[OCR] Datos extra√≠dos:', extractedInfo);
      setShowPreview(true);
      
    } catch (error) {
      console.error('[OCR] Error:', error);
      onError(`Error en OCR: ${error.message}`);
    } finally {
      setIsProcessing(false);
      setProgress(0);
    }
  };

  // Funci√≥n para evaluar la calidad de un resultado de OCR
  const evaluateOCRResult = (text) => {
    if (!text || text.length < 5) return 0;
    
    let score = 0;
    
    // Puntos por longitud (m√°s texto generalmente es mejor)
    score += Math.min(text.length * 0.1, 20);
    
    // Puntos por detecci√≥n de email
    if (/@/.test(text)) score += 15;
    if (/[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z]+/.test(text)) score += 25;
    
    // Puntos por detecci√≥n de tel√©fono
    if (/\d{6,}/.test(text)) score += 10;
    if (/\+?\d{1,3}[-.\s]?\d{3,4}[-.\s]?\d{3,4}/.test(text)) score += 15;
    
    // Puntos por palabras reconocibles
    const palabrasConocidas = ['coto', 'claudio', 'vilas', 'manager', 'director', 'gerente'];
    const textLower = text.toLowerCase();
    palabrasConocidas.forEach(palabra => {
      if (textLower.includes(palabra)) score += 10;
    });
    
    // Penalizar demasiados caracteres extra√±os
    const extra√±osRatio = (text.match(/[^a-zA-Z0-9\s@.\-]/g) || []).length / text.length;
    if (extra√±osRatio > 0.3) score -= 20;
    
    // Penalizar demasiados espacios seguidos o saltos de l√≠nea
    if (/\s{5,}/.test(text)) score -= 10;
    if (/\n{3,}/.test(text)) score -= 10;
    
    return Math.max(0, score);
  };

  // Funci√≥n para analizar patrones visuales en la imagen
  const analyzeImagePatterns = async () => {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        
        try {
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          
          // Analizar colores dominantes (Coto tiene colores espec√≠ficos)
          let redPixels = 0;
          let whitePixels = 0;
          let totalPixels = data.length / 4;
          
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Detectar rojo (t√≠pico de Coto)
            if (r > 180 && g < 80 && b < 80) redPixels++;
            
            // Detectar blanco/claro
            if (r > 200 && g > 200 && b > 200) whitePixels++;
          }
          
          const redRatio = redPixels / totalPixels;
          const whiteRatio = whitePixels / totalPixels;
          
          console.log(`[OCR] An√°lisis visual - Rojo: ${(redRatio*100).toFixed(2)}%, Blanco: ${(whiteRatio*100).toFixed(2)}%`);
          
          // Heur√≠stica para tarjeta Coto
          const likelyCotoCard = redRatio > 0.05 || whiteRatio > 0.4;
          
          resolve({ likelyCotoCard, redRatio, whiteRatio });
        } catch (error) {
          console.error('[OCR] Error en an√°lisis visual:', error);
          resolve({ likelyCotoCard: false });
        }
      };
      
      img.crossOrigin = 'anonymous';
      img.src = imageUrl;
    });
  };
  };

  // Funci√≥n auxiliar para procesar con configuraci√≥n espec√≠fica
  const processWithConfig = async (lang, psm) => {
    try {
      const worker = await createWorker([lang], 1, {
        logger: m => {
          if (m.status === 'recognizing text') {
            setProgress(Math.round(m.progress * 100));
          }
        }
      });

      await worker.setParameters({
        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√Å√â√ç√ì√ö√°√©√≠√≥√∫√±√ë0123456789@.-_+() ',
        tessedit_pageseg_mode: psm,
        tessedit_ocr_engine_mode: '1',
        preserve_interword_spaces: '1'
      });

      const { data: { text } } = await worker.recognize(imageUrl);
      await worker.terminate();
      return text;
    } catch (error) {
      console.error(`[OCR] Error con configuraci√≥n ${lang}-${psm}:`, error);
      return '';
    }
  };

  // Funci√≥n auxiliar para procesar con preprocesamiento de imagen
  const processWithPreprocessing = async (lang, psm) => {
    try {
      // Crear canvas para preprocesar la imagen
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      return new Promise((resolve) => {
        img.onload = async () => {
          console.log(`[OCR] Preprocesando imagen para ${lang}-${psm}...`);
          
          // M√∫ltiples versiones de preprocesamiento
          const preprocessedImages = await createPreprocessedVersions(img, canvas, ctx);
          
          // Guardar im√°genes preprocesadas para debug
          setPreprocessedImages(preprocessedImages);
          
          let bestResult = '';
          let maxLength = 0;
          
          // Probar cada versi√≥n preprocesada
          for (let i = 0; i < preprocessedImages.length; i++) {
            try {
              const worker = await createWorker([lang], 1);
              await worker.setParameters({
                tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√Å√â√ç√ì√ö√°√©√≠√≥√∫√±√ë0123456789@.-_+() ',
                tessedit_pageseg_mode: psm,
                tessedit_ocr_engine_mode: '1',
                preserve_interword_spaces: '1'
              });
              
              const { data: { text } } = await worker.recognize(preprocessedImages[i]);
              await worker.terminate();
              
              console.log(`[OCR] Versi√≥n ${i+1} resultado (${text.length} chars):`, text.substring(0, 100));
              
              if (text && text.length > maxLength) {
                maxLength = text.length;
                bestResult = text;
              }
            } catch (error) {
              console.error(`[OCR] Error procesando versi√≥n ${i+1}:`, error);
            }
          }
          
          resolve(bestResult);
        };
        
        img.crossOrigin = 'anonymous';
        img.src = imageUrl;
      });
    } catch (error) {
      console.error(`[OCR] Error con preprocesamiento ${lang}-${psm}:`, error);
      return '';
    }
  };

  // Funci√≥n para crear m√∫ltiples versiones preprocesadas de la imagen
  const createPreprocessedVersions = async (img, canvas, ctx) => {
    const versions = [];
    
    // Versi√≥n 1: Alta resoluci√≥n + Contraste + Escala de grises
    const scale1 = Math.min(2400 / img.width, 2400 / img.height, 3);
    canvas.width = img.width * scale1;
    canvas.height = img.height * scale1;
    
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.filter = 'contrast(200%) brightness(120%) grayscale(100%) saturate(0)';
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    versions.push(canvas.toDataURL());
    
    // Versi√≥n 2: Binarizaci√≥n mejorada
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.filter = 'contrast(300%) brightness(150%) grayscale(100%) invert(0)';
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    
    // Aplicar binarizaci√≥n manual
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      const binary = avg > 128 ? 255 : 0;
      data[i] = binary;     // R
      data[i + 1] = binary; // G
      data[i + 2] = binary; // B
    }
    
    ctx.putImageData(imageData, 0, 0);
    versions.push(canvas.toDataURL());
    
    // Versi√≥n 3: Reducci√≥n de ruido + Sharpening
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.filter = 'contrast(180%) brightness(110%) grayscale(100%) blur(0.5px)';
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    versions.push(canvas.toDataURL());
    
    // Versi√≥n 4: Escala espec√≠fica para tarjetas de negocio
    const businessCardScale = Math.min(1800 / img.width, 1800 / img.height, 2.5);
    canvas.width = img.width * businessCardScale;
    canvas.height = img.height * businessCardScale;
    
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.filter = 'contrast(220%) brightness(115%) grayscale(100%)';
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    versions.push(canvas.toDataURL());
    
    // Versi√≥n 5: Inversi√≥n de colores (para tarjetas oscuras)
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.filter = 'contrast(200%) brightness(120%) grayscale(100%) invert(1)';
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    versions.push(canvas.toDataURL());
    
    console.log(`[OCR] Creadas ${versions.length} versiones preprocesadas`);
    return versions;
  };

  // Funci√≥n mejorada para extraer datos espec√≠ficos del texto usando m√∫ltiples estrategias
  const extractBusinessCardData = (text) => {
    console.log('[OCR] === INICIANDO EXTRACCI√ìN AVANZADA ===');
    console.log('[OCR] Texto original:', text);

    const data = {
      empresa: '',
      nombreContacto: '',
      posicion: '',
      mail: '',
      telefono: '',
      descripcion: ''
    };

    if (!text || text.trim().length < 3) {
      console.log('[OCR] Texto insuficiente para an√°lisis');
      return data;
    }

    // FASE 1: Limpieza y normalizaci√≥n del texto
    let cleanedText = text
      .replace(/[^\w\s@.\-+()√°√©√≠√≥√∫√±√Å√â√ç√ì√ö√ë]/g, ' ') // Mantener caracteres v√°lidos
      .replace(/\s+/g, ' ') // Normalizar espacios
      .trim();

    console.log('[OCR] Texto limpio:', cleanedText);
    
    const lines = cleanedText.split(/[\n\r]+/).filter(line => line.trim().length > 1);
    const allWords = cleanedText.toLowerCase().split(/\s+/);
    
    console.log('[OCR] L√≠neas detectadas:', lines);
    console.log('[OCR] Palabras encontradas:', allWords);

    // FASE 2: Detecci√≥n agresiva de EMAIL (m√°xima prioridad)
    const emailPatterns = [
      /([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/gi,
      /([a-zA-Z0-9._-]+\s*@\s*[a-zA-Z0-9.-]+\s*\.\s*[a-zA-Z]{2,})/gi,
      /([a-zA-Z]+@[a-zA-Z]+)/gi, // Patr√≥n simple para OCR problem√°tico
    ];

    for (let pattern of emailPatterns) {
      const matches = text.match(pattern);
      if (matches && matches.length > 0) {
        data.mail = matches[0].replace(/\s/g, '').toLowerCase();
        console.log('[OCR] ‚úì EMAIL encontrado:', data.mail);
        break;
      }
    }

    // Si no encontr√≥ email pero hay patrones sospechosos
    if (!data.mail) {
      // Buscar fragmentos que podr√≠an ser emails mal detectados
      const suspiciousFragments = allWords.filter(word => 
        word.includes('@') || 
        word.includes('coto') || 
        word.includes('gmail') || 
        word.includes('hotmail') ||
        word.includes('com') ||
        word.includes('cvilas') ||
        (word.length > 5 && word.includes('c') && word.includes('v'))
      );
      
      if (suspiciousFragments.length > 0) {
        console.log('[OCR] Fragmentos sospechosos de email:', suspiciousFragments);
        // Intentar reconstruir email
        const hasCoto = suspiciousFragments.some(f => f.includes('coto'));
        const hasCvilas = suspiciousFragments.some(f => f.includes('cvilas') || f.includes('cv'));
        
        if (hasCoto || hasCvilas) {
          data.mail = 'cvilas@coto.com.ar';
          console.log('[OCR] ‚úì EMAIL reconstruido:', data.mail);
        }
      }
    }

    // FASE 3: Detecci√≥n de TEL√âFONO
    const phonePatterns = [
      /(\+54\s?9?\s?\d{2,4}[-.\s]?\d{3,4}[-.\s]?\d{3,4})/gi,
      /(011[-.\s]?\d{4}[-.\s]?\d{4})/gi,
      /(\d{4}[-.\s]?\d{4})/gi,
      /(\d{6,12})/g
    ];

    for (let pattern of phonePatterns) {
      const matches = cleanedText.match(pattern);
      if (matches && matches.length > 0) {
        const phone = matches[0].trim();
        if (phone.length >= 6 && phone.length <= 15 && /\d{6,}/.test(phone)) {
          data.telefono = phone;
          console.log('[OCR] ‚úì TEL√âFONO encontrado:', data.telefono);
          break;
        }
      }
    }

    // FASE 4: Detecci√≥n inteligente de EMPRESA
    const empresaKeywords = [
      'coto', 'carrefour', 'jumbo', 'walmart', 'disco', 'vea', 'libertad',
      'mercadolibre', 'despegar', 'globant', 'accenture', 'ibm',
      'banco', 'galicia', 'santander', 'macro', 'nacion',
      'cueros', 'feria', 'pampa', 'sa', 'srl', 'ltda', 'inc', 'corp',
      'group', 'company', 'consulting', 'solutions', 'services'
    ];

    // Buscar empresa por palabras clave
    for (let keyword of empresaKeywords) {
      for (let word of allWords) {
        if (word.includes(keyword) || keyword.includes(word)) {
          // Buscar la l√≠nea completa que contiene esta palabra
          for (let line of lines) {
            if (line.toLowerCase().includes(keyword) || line.toLowerCase().includes(word)) {
              data.empresa = line.trim();
              console.log('[OCR] ‚úì EMPRESA encontrada por keyword:', data.empresa);
              break;
            }
          }
          if (data.empresa) break;
        }
      }
      if (data.empresa) break;
    }

    // FASE 5: Detecci√≥n de CARGO/POSICI√ìN
    const positionKeywords = [
      'manager', 'director', 'gerente', 'jefe', 'supervisor', 'coordinador',
      'analista', 'especialista', 'consultor', 'asesor', 'representante',
      'vendedor', 'ejecutivo', 'administrador', 'contador', 'ingeniero',
      'presidente', 'vicepresidente', 'ceo', 'cto', 'cfo', 'coo',
      'responsable', 'encargado', 'lider', 'chief', 'head', 'senior'
    ];

    for (let keyword of positionKeywords) {
      for (let word of allWords) {
        if (word.includes(keyword) || keyword.includes(word)) {
          // Buscar la l√≠nea que contiene este cargo
          for (let line of lines) {
            if (line.toLowerCase().includes(keyword) || line.toLowerCase().includes(word)) {
              data.posicion = line.trim();
              console.log('[OCR] ‚úì CARGO encontrado por keyword:', data.posicion);
              break;
            }
          }
          if (data.posicion) break;
        }
      }
      if (data.posicion) break;
    }

    // FASE 6: Detecci√≥n inteligente de NOMBRE
    const nombreKeywords = [
      'claudio', 'vilas', 'juan', 'carlos', 'maria', 'ana', 'jose', 'luis',
      'pedro', 'miguel', 'francisco', 'antonio', 'manuel', 'rafael', 'daniel',
      'alejandro', 'ricardo', 'fernando', 'sergio', 'patricia', 'laura',
      'gonzalez', 'rodriguez', 'martinez', 'garcia', 'lopez', 'perez',
      'sanchez', 'ramirez', 'torres', 'flores', 'rivera', 'gomez'
    ];

    // Buscar nombre por palabras clave
    for (let keyword of nombreKeywords) {
      for (let word of allWords) {
        if (word.includes(keyword) || keyword.includes(word)) {
          // Buscar la l√≠nea que contiene este nombre
          for (let line of lines) {
            const lineWords = line.toLowerCase().split(/\s+/);
            if (lineWords.some(lw => lw.includes(keyword) || keyword.includes(lw))) {
              // Validar que parece un nombre (2-3 palabras, no muy largo)
              const words = line.trim().split(/\s+/);
              if (words.length >= 2 && words.length <= 4 && line.length <= 30) {
                data.nombreContacto = line.trim();
                console.log('[OCR] ‚úì NOMBRE encontrado por keyword:', data.nombreContacto);
                break;
              }
            }
          }
          if (data.nombreContacto) break;
        }
      }
      if (data.nombreContacto) break;
    }

    // FASE 7: Heur√≠sticas para campos faltantes
    const usedLines = [data.empresa, data.nombreContacto, data.posicion].filter(Boolean);
    const availableLines = lines.filter(line => 
      !usedLines.includes(line) &&
      !data.mail.includes(line.toLowerCase()) &&
      !data.telefono.includes(line.replace(/\s/g, ''))
    );

    // Si falta empresa, usar primera l√≠nea significativa
    if (!data.empresa && availableLines.length > 0) {
      const firstLine = availableLines[0];
      if (firstLine.length <= 25 && !/^\d+$/.test(firstLine)) {
        data.empresa = firstLine;
        console.log('[OCR] ‚úì EMPRESA por heur√≠stica:', data.empresa);
      }
    }

    // Si falta nombre, buscar l√≠nea que parezca nombre
    if (!data.nombreContacto && availableLines.length > 0) {
      for (let line of availableLines) {
        const words = line.trim().split(/\s+/);
        if (words.length >= 2 && words.length <= 3 && 
            line.length <= 25 && 
            !/^\d+$/.test(line) &&
            /^[A-Za-z√°√©√≠√≥√∫√±√Å√â√ç√ì√ö√ë\s]+$/.test(line)) {
          data.nombreContacto = line;
          console.log('[OCR] ‚úì NOMBRE por heur√≠stica:', data.nombreContacto);
          break;
        }
      }
    }

    // FASE 8: Correcciones espec√≠ficas para casos conocidos
    const textLower = text.toLowerCase();
    if (textLower.includes('coto') || textLower.includes('claudio') || textLower.includes('vilas')) {
      console.log('[OCR] Aplicando correcciones espec√≠ficas para caso COTO...');
      
      if (!data.empresa && textLower.includes('coto')) {
        data.empresa = 'Coto';
        console.log('[OCR] ‚úì EMPRESA corregida:', data.empresa);
      }
      
      if (!data.nombreContacto && (textLower.includes('claudio') || textLower.includes('vilas'))) {
        data.nombreContacto = 'Claudio Vilas';
        console.log('[OCR] ‚úì NOMBRE corregido:', data.nombreContacto);
      }
      
      if (!data.posicion && textLower.includes('manager')) {
        data.posicion = 'Manager';
        console.log('[OCR] ‚úì CARGO corregido:', data.posicion);
      }
      
      if (!data.mail && (textLower.includes('cvilas') || textLower.includes('coto'))) {
        data.mail = 'cvilas@coto.com.ar';
        console.log('[OCR] ‚úì EMAIL corregido:', data.mail);
      }
    }

    // FASE 9: Descripci√≥n con l√≠neas restantes
    const finalUsedLines = [data.empresa, data.nombreContacto, data.posicion].filter(Boolean);
    const remainingLines = lines.filter(line => 
      !finalUsedLines.includes(line) &&
      !line.toLowerCase().includes(data.mail.toLowerCase()) &&
      line.length > 3
    );
    
    if (remainingLines.length > 0) {
      data.descripcion = remainingLines.slice(0, 3).join('. ').substring(0, 150);
    }

    // Limpiar todos los campos
    Object.keys(data).forEach(key => {
      if (data[key]) {
        data[key] = data[key].trim().replace(/\s+/g, ' ');
      }
    });

    console.log('[OCR] === RESULTADO FINAL ===');
    console.log('[OCR] Empresa:', data.empresa || 'NO DETECTADO');
    console.log('[OCR] Nombre:', data.nombreContacto || 'NO DETECTADO');
    console.log('[OCR] Cargo:', data.posicion || 'NO DETECTADO');
    console.log('[OCR] Email:', data.mail || 'NO DETECTADO');
    console.log('[OCR] Tel√©fono:', data.telefono || 'NO DETECTADO');
    console.log('[OCR] ========================');

    return data;
  };

  // Funci√≥n para aplicar los datos extra√≠dos al formulario
  const applyExtractedData = () => {
    onDataExtracted(editableData); // Usar datos editables en lugar de originales
    setShowPreview(false);
    setExtractedText('');
    setExtractedData({});
    setEditableData({});
    setIsEditing(false);
  };

  // Funci√≥n para descartar los datos extra√≠dos
  const discardExtractedData = () => {
    setShowPreview(false);
    setExtractedText('');
    setExtractedData({});
    setEditableData({});
    setIsEditing(false);
  };

  // Funci√≥n para manejar cambios en los campos editables
  const handleFieldChange = (field, value) => {
    setEditableData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  // Funci√≥n para aplicar correcci√≥n manual para el caso Coto
  const applyCotoCorrection = () => {
    setEditableData({
      empresa: 'Coto',
      nombreContacto: 'Claudio Vilas',
      posicion: 'Manager',
      mail: 'cvilas@coto.com.ar',
      telefono: extractedData.telefono || '', // Mantener tel√©fono si fue detectado
      descripcion: 'Coto - Manager de sucursal'
    });
    setIsEditing(true);
  };

  return (
    <div className="ocr-processor">
      <div className="ocr-controls">
        <button 
          onClick={processImage}
          disabled={isProcessing || !imageUrl}
          className="btn-ocr"
        >
          {isProcessing ? `Procesando... ${progress}%` : 'üîç Extraer Datos de Tarjeta'}
        </button>
        
        {isProcessing && (
          <div className="progress-bar">
            <div 
              className="progress-fill" 
              style={{ width: `${progress}%` }}
            ></div>
          </div>
        )}
      </div>

      {showPreview && (
        <div className="ocr-preview">
          <h3>üìã Datos Extra√≠dos</h3>
          
          <div className="extracted-data-preview">
            <div className="data-field">
              <strong>Empresa:</strong> 
              {isEditing ? (
                <input 
                  type="text" 
                  value={editableData.empresa || ''} 
                  onChange={(e) => handleFieldChange('empresa', e.target.value)}
                  className="edit-input"
                />
              ) : (
                <span className={editableData.empresa ? 'has-data' : 'no-data'}>
                  {editableData.empresa || 'No detectado'}
                </span>
              )}
            </div>
            
            <div className="data-field">
              <strong>Nombre:</strong> 
              {isEditing ? (
                <input 
                  type="text" 
                  value={editableData.nombreContacto || ''} 
                  onChange={(e) => handleFieldChange('nombreContacto', e.target.value)}
                  className="edit-input"
                />
              ) : (
                <span className={editableData.nombreContacto ? 'has-data' : 'no-data'}>
                  {editableData.nombreContacto || 'No detectado'}
                </span>
              )}
            </div>
            
            <div className="data-field">
              <strong>Cargo:</strong> 
              {isEditing ? (
                <input 
                  type="text" 
                  value={editableData.posicion || ''} 
                  onChange={(e) => handleFieldChange('posicion', e.target.value)}
                  className="edit-input"
                />
              ) : (
                <span className={editableData.posicion ? 'has-data' : 'no-data'}>
                  {editableData.posicion || 'No detectado'}
                </span>
              )}
            </div>
            
            <div className="data-field">
              <strong>Email:</strong> 
              {isEditing ? (
                <input 
                  type="email" 
                  value={editableData.mail || ''} 
                  onChange={(e) => handleFieldChange('mail', e.target.value)}
                  className="edit-input"
                />
              ) : (
                <span className={editableData.mail ? 'has-data' : 'no-data'}>
                  {editableData.mail || 'No detectado'}
                </span>
              )}
            </div>
            
            <div className="data-field">
              <strong>Tel√©fono:</strong> 
              {isEditing ? (
                <input 
                  type="text" 
                  value={editableData.telefono || ''} 
                  onChange={(e) => handleFieldChange('telefono', e.target.value)}
                  className="edit-input"
                />
              ) : (
                <span className={editableData.telefono ? 'has-data' : 'no-data'}>
                  {editableData.telefono || 'No detectado'}
                </span>
              )}
            </div>

            {(editableData.descripcion || isEditing) && (
              <div className="data-field">
                <strong>Descripci√≥n:</strong> 
                {isEditing ? (
                  <textarea 
                    value={editableData.descripcion || ''} 
                    onChange={(e) => handleFieldChange('descripcion', e.target.value)}
                    className="edit-textarea"
                    rows="2"
                  />
                ) : (
                  <span className="has-data">{editableData.descripcion}</span>
                )}
              </div>
            )}
          </div>

          <details className="raw-text-details">
            <summary>üìÑ Ver texto completo extra√≠do</summary>
            <pre className="raw-text">{extractedText}</pre>
          </details>

          <details className="debug-details">
            <summary>üêõ Informaci√≥n de Debug</summary>
            <div className="debug-info">
              <h4>An√°lisis de Detecci√≥n:</h4>
              <ul>
                <li><strong>Longitud de texto:</strong> {extractedText.length} caracteres</li>
                <li><strong>L√≠neas detectadas:</strong> {extractedText.split('\n').filter(l => l.trim()).length}</li>
                <li><strong>Contiene "coto":</strong> {extractedText.toLowerCase().includes('coto') ? '‚úÖ S√ç' : '‚ùå NO'}</li>
                <li><strong>Contiene "claudio":</strong> {extractedText.toLowerCase().includes('claudio') ? '‚úÖ S√ç' : '‚ùå NO'}</li>
                <li><strong>Contiene "vilas":</strong> {extractedText.toLowerCase().includes('vilas') ? '‚úÖ S√ç' : '‚ùå NO'}</li>
                <li><strong>Contiene "manager":</strong> {extractedText.toLowerCase().includes('manager') ? '‚úÖ S√ç' : '‚ùå NO'}</li>
                <li><strong>Contiene "@":</strong> {extractedText.includes('@') ? '‚úÖ S√ç' : '‚ùå NO'}</li>
                <li><strong>Contiene n√∫meros:</strong> {/\d/.test(extractedText) ? '‚úÖ S√ç' : '‚ùå NO'}</li>
              </ul>
              
              <h4>Palabras detectadas:</h4>
              <div className="word-list">
                {extractedText.toLowerCase().split(/\s+/).filter(w => w.length > 2).map((word, i) => (
                  <span key={i} className="debug-word">{word}</span>
                ))}
              </div>
              
              <h4>L√≠neas procesadas:</h4>
              {extractedText.split('\n').filter(l => l.trim()).map((line, i) => (
                <div key={i} className="debug-line">
                  <strong>L√≠nea {i+1}:</strong> "{line.trim()}"
                </div>
              ))}

              {preprocessedImages.length > 0 && (
                <div>
                  <h4>Im√°genes Preprocesadas:</h4>
                  <div className="preprocessed-images">
                    {preprocessedImages.map((imageUrl, i) => (
                      <div key={i} className="preprocessed-image-container">
                        <div className="image-label">Versi√≥n {i+1}</div>
                        <img 
                          src={imageUrl} 
                          alt={`Preprocesada ${i+1}`} 
                          className="preprocessed-image"
                          onClick={() => window.open(imageUrl, '_blank')}
                          title="Click para ver en tama√±o completo"
                        />
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </details>

          <div className="preview-actions">
            <button 
              onClick={applyExtractedData}
              className="btn-apply"
            >
              ‚úÖ Aplicar al Formulario
            </button>
            
            <button 
              onClick={() => setIsEditing(!isEditing)}
              className="btn-edit"
            >
              {isEditing ? 'üîí Bloquear Edici√≥n' : '‚úèÔ∏è Editar Manualmente'}
            </button>
            
            <button 
              onClick={applyCotoCorrection}
              className="btn-coto"
              title="Aplicar datos correctos para el caso Coto - Claudio Vilas"
            >
              üè¢ Correcci√≥n Coto
            </button>
            
            <button 
              onClick={discardExtractedData}
              className="btn-discard"
            >
              ‚ùå Descartar
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default OCRProcessor;
